<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>农场材料计算器</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            background: #f4f8fc;
            font-family: '微软雅黑', Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        .navbar {
            background: #4ea1ff;
            color: #fff;
            padding: 0 32px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }
        .navbar .logo {
            font-size: 22px;
            font-weight: bold;
            letter-spacing: 2px;
        }
        .navbar .nav-links a {
            color: #fff;
            text-decoration: none;
            margin-left: 24px;
            font-size: 16px;
            transition: color 0.2s;
        }
        .navbar .nav-links a:hover {
            color: #eaf6ff;
        }
        .card {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            margin: 32px auto 0 auto;
            padding: 24px 32px;
            max-width: 900px;
        }
        .input-row {
            display: flex;
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
        }
        input[type="text"], input[type="number"] {
            padding: 10px;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            font-size: 16px;
            width: 200px;
            background: #f8fafc;
            transition: border 0.2s;
        }
        input[type="text"]:focus, input[type="number"]:focus {
            border: 1.5px solid #4ea1ff;
            outline: none;
        }
        .btn-primary {
            background: #4ea1ff;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 10px 24px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
            margin-right: 8px;
        }
        .btn-primary:hover {
            background: #357ec7;
        }
        .btn-secondary {
            background: #444;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 10px 24px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn-secondary:hover {
            background: #222;
        }
        .notice {
            background: #eaf6ff;
            color: #3178c6;
            border-radius: 8px;
            padding: 12px 24px;
            margin: 24px auto 0 auto;
            max-width: 900px;
            font-size: 15px;
        }
        .result-card {
            margin-top: 24px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 24px 32px;
            max-width: 900px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .result-card ul {
            padding-left: 24px;
        }
        .result-card b {
            font-size: 18px;
            color: #333;
        }
        /* 配方管理模态框美化 */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.18);
            z-index: 1000;
        }
        .modal-content {
            background: #fff;
            margin: 60px auto;
            padding: 32px 32px 24px 32px;
            width: 90%;
            max-width: 520px;
            border-radius: 16px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.13);
            position: relative;
        }
        .close {
            position: absolute;
            right: 24px;
            top: 18px;
            font-size: 28px;
            color: #aaa;
            cursor: pointer;
            transition: color 0.2s;
        }
        .close:hover { color: #4ea1ff; }
        .recipe-list {
            margin-top: 20px;
            max-height: 220px;
            overflow-y: auto;
        }
        .recipe-item {
            margin-bottom: 10px;
            padding: 10px 12px;
            background: #f8fafc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .recipe-item strong { color: #3178c6; }
        .recipe-item button {
            width: auto;
            margin-left: 8px;
            padding: 6px 14px;
            font-size: 14px;
            border-radius: 5px;
        }
        .level-exp-info {
            color: #4ea1ff;
            font-size: 13px;
            font-weight: 500;
        }
        .recipe-category {
            color: #888;
            font-size: 13px;
        }
        .recipe-materials {
            color: #666;
            font-size: 14px;
            margin-top: 4px;
        }
        .modal-content h3 {
            margin-top: 0;
            color: #3178c6;
        }
        .modal-content h4 {
            margin-bottom: 8px;
            margin-top: 18px;
            color: #4ea1ff;
        }
        @media (max-width: 600px) {
            .card, .result-card, .notice { padding: 12px 6px; }
            .modal-content { padding: 12px 6px; }
            .input-row { flex-direction: column; gap: 8px; }
            input[type="text"], input[type="number"] { width: 100%; }
        }
        .autocomplete-list {
            position: absolute;
            background: #fff;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            z-index: 2000;
            max-height: 220px;
            overflow-y: auto;
            width: 200px;
            margin-top: 2px;
        }
        .autocomplete-item {
            padding: 8px 14px;
            cursor: pointer;
            font-size: 16px;
            color: #333;
        }
        .autocomplete-item.active, .autocomplete-item:hover {
            background: #eaf6ff;
            color: #3178c6;
        }
    </style>
</head>
<body>
    <!-- 顶部导航栏 -->
    <div class="navbar">
        <div class="logo">农场材料计算器</div>
        <div class="nav-links">
            <a href="#" onclick="openImportExportModal();return false;">导入/导出配方</a>
        </div>
    </div>

    <!-- 卡片式输入区 -->
    <div class="card input-card" style="position:relative;">
        <div class="input-row">
            <div style="position:relative;">
                <input type="text" id="item" placeholder="请输入配方名称" autocomplete="off">
                <div id="autocomplete-list" class="autocomplete-list" style="display:none;"></div>
            </div>
            <input type="number" id="count" min="1" value="1" placeholder="数量">
            <button class="btn-primary" onclick="calculate()">计算材料</button>
            <button class="btn-secondary" onclick="openModal()">管理配方</button>
        </div>
    </div>

    <!-- 公告栏 -->
    <div class="notice">
        <b>公告：</b>材料列表和配方支持自定义，界面持续优化中，欢迎反馈建议！
    </div>

    <!-- 结果展示区 -->
    <div class="result-card" id="result"></div>

    <!-- 导入/导出配方模态框 -->
    <div id="importExportModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeImportExportModal()">&times;</span>
            <h3>导入/导出配方</h3>
            <div style="margin-bottom:12px;">
                <button class="btn-primary" onclick="exportRecipes()">导出配方</button>
                <label class="btn-secondary" style="margin-left:8px;cursor:pointer;">
                    导入配方
                    <input type="file" id="importFile" accept="application/json" style="display:none" onchange="importRecipes(event)">
                </label>
                <button class="btn-secondary" style="margin-left:8px;background:#e57373;" onclick="clearRecipes()">清空配方库</button>
            </div>
            <div style="color:#888;font-size:14px;">导出会下载当前配方库为JSON文件，导入会覆盖当前配方库。清空配方库会删除所有本地配方数据并刷新页面。</div>
        </div>
    </div>

    <!-- 配方管理模态框 -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h3>配方管理</h3>
            <div style="margin-bottom:12px;">
                <button class="btn-secondary" onclick="showRecipeStats()" style="margin-right:8px;">配方统计</button>
                <button class="btn-secondary" onclick="resetFilters()" style="margin-right:8px;">重置筛选</button>
                <button class="btn-secondary" onclick="jumpToLevel(1)" style="margin-right:4px;">Lv.1</button>
                <button class="btn-secondary" onclick="jumpToLevel(10)" style="margin-right:4px;">Lv.10</button>
                <button class="btn-secondary" onclick="jumpToLevel(20)" style="margin-right:4px;">Lv.20</button>
                <button class="btn-secondary" onclick="jumpToLevel(30)" style="margin-right:4px;">Lv.30</button>
                <button class="btn-secondary" onclick="jumpToLevel(40)" style="margin-right:8px;">Lv.40</button>
                <button class="btn-secondary" onclick="jumpToExpRange(0, 100)" style="margin-right:4px;">Exp.0-100</button>
                <button class="btn-secondary" onclick="jumpToExpRange(200, 300)" style="margin-right:4px;">Exp.200-300</button>
                <button class="btn-secondary" onclick="jumpToExpRange(300, 400)" style="margin-right:4px;">Exp.300-400</button>
            </div>
            <div class="recipe-list" id="recipeList"></div>
            <h4>添加新配方</h4>
            <input type="text" id="newRecipeName" placeholder="配方名称">
            <select id="newRecipeCategory" style="margin-bottom:12px;padding:8px 12px;border-radius:6px;border:1px solid #d0d7de;font-size:15px;">
                <option value="原木制作">原木制作</option>
                <option value="陶艺制作">陶艺制作</option>
                <option value="缝纫制作">缝纫制作</option>
                <option value="金属制作">金属制作</option>
                <option value="皮革制作">皮革制作</option>
                <option value="料理制作">料理制作</option>
                <option value="其他">其他</option>
            </select>
            <div style="display:flex;gap:8px;margin-bottom:12px;">
                <input type="number" id="newRecipeLevel" placeholder="等级要求" min="1" style="flex:1;padding:8px 12px;border-radius:6px;border:1px solid #d0d7de;font-size:15px;">
                <input type="number" id="newRecipeExp" placeholder="单次经验" min="0" style="flex:1;padding:8px 12px;border-radius:6px;border:1px solid #d0d7de;font-size:15px;">
            </div>
            <div style="position:relative;margin-bottom:8px;">
                <input type="text" id="materialSuggestInput" placeholder="输入材料名，支持联想补全" autocomplete="off" style="width:100%;padding:8px 12px;border-radius:6px;border:1px solid #d0d7de;font-size:15px;">
                <div id="material-autocomplete-list" class="autocomplete-list" style="display:none;"></div>
            </div>
            <input type="text" id="newRecipeMaterials" placeholder="材料（格式：材料1：数量1，材料2：数量2）">
            <button class="btn-primary" style="margin-top:8px;" onclick="addRecipe()">添加配方</button>
        </div>
    </div>

<script>
// 先从localStorage读取recipes
let recipes = JSON.parse(localStorage.getItem('recipes')) || {
    "面包": { "小麦": 3, "水": 1 },
    "蛋糕": { "面粉": 2, "鸡蛋": 3, "牛奶": 1 },
    "面粉": { "小麦": 2 },
    "三明治": { "面包": 2, "鸡蛋": 1, "生菜": 1 },
    "35级羊毛": { "羊毛": 3, "染料": 1 },
    "木色拼接双层书柜": { "木板": 4, "钉子": 8, "木色染料": 2 },
    "木色染料": { "染料": 1, "木材": 1 },
    // 基础材料：小麦、水、鸡蛋、牛奶、生菜、羊毛、染料、木板、钉子、木材
};

// 名称到ID的映射
let nameToIdMap = {};

// 调试函数：查看配方结构
function debugRecipe(recipeName) {
    const recipe = getRecipeByName(recipeName);
    if (recipe) {
        console.log('配方结构:', recipeName, recipe);
        alert(`配方「${recipeName}」的结构已输出到控制台`);
    } else {
        alert(`未找到配方「${recipeName}」`);
    }
}

// 调试函数：查看所有配方
function debugAllRecipes() {
    console.log('所有配方数据:', recipes);
    console.log('名称到ID映射:', nameToIdMap);
    alert('所有配方数据已输出到控制台');
}

// 兼容旧数据，升级为新结构，并覆盖localStorage
function upgradeRecipesStructure() {
    let changed = false;
    
    // 检查是否是新结构（有name字段）
    const isNewStructure = Object.values(recipes).some(recipe => recipe.name);
    
    if (isNewStructure) {
        // 新结构：通过name字段建立映射
        nameToIdMap = {};
        for (const [id, recipe] of Object.entries(recipes)) {
            if (recipe.name) {
                nameToIdMap[recipe.name] = id;
            }
        }
    } else {
        // 旧结构：升级为新结构
        for (const [name, value] of Object.entries(recipes)) {
            // 检查是否为旧结构（直接包含材料，没有materials字段）
            if (!value.materials && typeof value === 'object') {
                // 检查是否包含材料数据（不是新结构）
                const hasMaterialData = Object.entries(value).some(([key, val]) => 
                    typeof val === 'number' && !['exp', 'lv'].includes(key)
                );
                if (hasMaterialData) {
                    recipes[name] = { 
                        category: "其他", 
                        exp: 0,
                        lv: 1,
                        materials: value,
                        isEvent: false
                    };
                    changed = true;
                }
            }
        }
        if (changed) localStorage.setItem('recipes', JSON.stringify(recipes));
    }
}
upgradeRecipesStructure();

// 通过名称获取配方
function getRecipeByName(name) {
    if (nameToIdMap[name]) {
        return recipes[nameToIdMap[name]];
    }
    // 兼容旧结构
    return recipes[name];
}

// 递归分解，统计基础材料（修复版本）
function getBaseMaterials(item, count, result, visited = new Set(), depth = 0) {
    const indent = '  '.repeat(depth);
    console.log(`${indent}分解物品: ${item}, 数量: ${count}, 深度: ${depth}`);
    
    // 防止循环依赖
    if (visited.has(item)) {
        console.warn(`${indent}检测到循环依赖: ${item}`);
        return;
    }
    
    visited.add(item);
    
    // 获取配方
    const recipe = getRecipeByName(item);
    
    // 检查是否存在配方
    if (recipe && recipe.materials) {
        console.log(`${indent}找到配方:`, recipe.materials);
        
        const { materials } = recipe;
        if (typeof materials === 'object' && materials !== null) {
            for (const [subItem, subCount] of Object.entries(materials)) {
                if (typeof subCount === 'number' && !isNaN(subCount)) {
                    const totalNeeded = subCount * count;
                    console.log(`${indent}需要 ${subItem} × ${totalNeeded}`);
                    // 递归分解子物品
                    getBaseMaterials(subItem, totalNeeded, result, new Set(visited), depth + 1);
                }
            }
        }
    } else {
        // 没有配方，当作基础材料
        console.log(`${indent}作为基础材料添加: ${item} × ${count}`);
        result[item] = (result[item] || 0) + count;
    }
}

// 计算并显示结果
function calculate() {
    const item = document.getElementById('item').value.trim();
    const count = parseInt(document.getElementById('count').value, 10);
    
    if (!item || count < 1) {
        document.getElementById('result').innerHTML = '<span style="color:#e57373">请输入正确的配方名称和数量！</span>';
        return;
    }
    
    // 检查是否存在配方
    const recipe = getRecipeByName(item);
    if (!recipe) {
        document.getElementById('result').innerHTML = `<span style="color:#e57373">未找到配方「${item}」，请检查名称或在配方管理中添加！</span>`;
        return;
    }
    
    try {
        const result = {};
        getBaseMaterials(item, count, result);
        
        if (Object.keys(result).length === 0) {
            document.getElementById('result').innerHTML = '<span style="color:#e57373">计算结果为空，请检查配方数据！</span>';
            return;
        }
        
        // 等级和经验值信息
        const { lv, exp, category } = recipe;
        const levelInfo = lv ? `等级要求：Lv.${lv}` : '';
        const expInfo = exp ? `单次经验：${exp}` : '';
        const levelExpText = [levelInfo, expInfo].filter(Boolean).join(' | ');
        const categoryText = category ? `[${category}]` : '';
        
        // 计算总经验
        let totalExp = '';
        if (exp && !isNaN(exp) && count > 1) {
            totalExp = `<span style='color:#e57373;font-size:13px;'>合成${count}个总经验：${exp} × ${count} = ${exp * count}</span>`;
        }
        
        let html = `<b>合成 ${count} 个「${item}」所需基础材料：</b>`;
        if (levelExpText || categoryText) {
            html += `<br><span style='color:#4ea1ff;font-size:14px;'>${categoryText} ${levelExpText}</span>`;
        }
        if (totalExp) html += `<br>${totalExp}`;
        html += '<ul>';
        for (const [mat, qty] of Object.entries(result)) {
            html += `<li>${mat} × ${qty}</li>`;
        }
        html += '</ul>';
        document.getElementById('result').innerHTML = html;
    } catch (error) {
        console.error('计算错误:', error);
        document.getElementById('result').innerHTML = '<span style="color:#e57373">计算出错，请检查配方数据！</span>';
    }
}

// 打开模态框
function openModal() {
    document.getElementById('modal').style.display = 'block';
    displayRecipes();
}

// 关闭模态框
function closeModal() {
    document.getElementById('modal').style.display = 'none';
}

// 分类列表
const CATEGORIES = ["原木制作", "陶艺制作", "缝纫制作", "金属制作", "皮革制作", "料理制作", "其他"];

// 当前筛选分类
let currentCategory = "全部";
let currentLevel = "全部";
let currentLevelRange = "全部";
let currentExpRange = "全部";
let currentSort = "名称";

// 配方管理区分类筛选下拉
function renderCategoryFilter() {
    const filterDiv = document.createElement('div');
    filterDiv.style.marginBottom = '12px';
    filterDiv.style.display = 'flex';
    filterDiv.style.gap = '12px';
    filterDiv.style.flexWrap = 'wrap';
    
    // 分类筛选
    const categorySelect = document.createElement('select');
    categorySelect.style.padding = '6px 12px';
    categorySelect.style.borderRadius = '6px';
    categorySelect.style.border = '1px solid #d0d7de';
    categorySelect.style.fontSize = '15px';
    categorySelect.innerHTML = `<option value="全部">全部分类</option>` +
        CATEGORIES.map(cat => `<option value="${cat}">${cat}</option>`).join('');
    categorySelect.value = currentCategory;
    categorySelect.onchange = function() {
        currentCategory = this.value;
        displayRecipes();
    };
    
    // 等级筛选
    const levelSelect = document.createElement('select');
    levelSelect.style.padding = '6px 12px';
    levelSelect.style.borderRadius = '6px';
    levelSelect.style.border = '1px solid #d0d7de';
    levelSelect.style.fontSize = '15px';
    levelSelect.innerHTML = `<option value="全部">全部等级</option>` +
        Array.from({length: 40}, (_, i) => i + 1).map(lv => `<option value="${lv}">Lv.${lv}</option>`).join('');
    levelSelect.value = currentLevel;
    levelSelect.onchange = function() {
        currentLevel = this.value;
        displayRecipes();
    };
    
    // 等级范围筛选
    const levelRangeSelect = document.createElement('select');
    levelRangeSelect.style.padding = '6px 12px';
    levelRangeSelect.style.borderRadius = '6px';
    levelRangeSelect.style.border = '1px solid #d0d7de';
    levelRangeSelect.style.fontSize = '15px';
    levelRangeSelect.innerHTML = `
        <option value="全部">全部等级</option>
        <option value="1-10">Lv.1-10</option>
        <option value="11-20">Lv.11-20</option>
        <option value="21-30">Lv.21-30</option>
        <option value="31-40">Lv.31-40</option>
        <option value="1-5">Lv.1-5</option>
        <option value="6-15">Lv.6-15</option>
        <option value="16-25">Lv.16-25</option>
        <option value="26-35">Lv.26-35</option>
        <option value="36-40">Lv.36-40</option>
    `;
    levelRangeSelect.value = currentLevelRange;
    levelRangeSelect.onchange = function() {
        currentLevelRange = this.value;
        displayRecipes();
    };
    
    // 经验值范围筛选
    const expRangeSelect = document.createElement('select');
    expRangeSelect.style.padding = '6px 12px';
    expRangeSelect.style.borderRadius = '6px';
    expRangeSelect.style.border = '1px solid #d0d7de';
    expRangeSelect.style.fontSize = '15px';
    expRangeSelect.innerHTML = `
        <option value="全部">全部经验值</option>
        <option value="0-100">0-100</option>
        <option value="101-200">101-200</option>
        <option value="201-300">201-300</option>
        <option value="301-400">301-400</option>
        <option value="0-50">0-50</option>
        <option value="51-150">51-150</option>
        <option value="151-250">151-250</option>
        <option value="251-350">251-350</option>
        <option value="351-400">351-400</option>
    `;
    expRangeSelect.value = currentExpRange;
    expRangeSelect.onchange = function() {
        currentExpRange = this.value;
        displayRecipes();
    };
    
    // 排序选择
    const sortSelect = document.createElement('select');
    sortSelect.style.padding = '6px 12px';
    sortSelect.style.borderRadius = '6px';
    sortSelect.style.border = '1px solid #d0d7de';
    sortSelect.style.fontSize = '15px';
    sortSelect.innerHTML = `
        <option value="名称">按名称</option>
        <option value="等级升序">按等级升序</option>
        <option value="等级降序">按等级降序</option>
        <option value="经验值升序">按经验值升序</option>
        <option value="经验值降序">按经验值降序</option>
        <option value="分类">按分类</option>
    `;
    sortSelect.value = currentSort;
    sortSelect.onchange = function() {
        currentSort = this.value;
        displayRecipes();
    };
    
    filterDiv.appendChild(categorySelect);
    filterDiv.appendChild(levelSelect);
    filterDiv.appendChild(levelRangeSelect);
    filterDiv.appendChild(expRangeSelect);
    filterDiv.appendChild(sortSelect);
    return filterDiv;
}

// 显示所有配方（带分类筛选）
function displayRecipes() {
    const recipeList = document.getElementById('recipeList');
    recipeList.innerHTML = '';
    recipeList.appendChild(renderCategoryFilter());
    
    // 获取所有配方
    const allRecipes = [];
    for (const [id, recipe] of Object.entries(recipes)) {
        if (recipe.name) {
            // 新结构
            allRecipes.push({ id, ...recipe });
        } else {
            // 旧结构兼容
            allRecipes.push({ id, name: id, ...recipe });
        }
    }
    
    // 筛选配方
    const filteredRecipes = allRecipes.filter(recipe => {
        const { name, category, materials, lv, exp } = recipe;
        if (currentCategory !== "全部" && category !== currentCategory) return false;
        if (currentLevel !== "全部" && lv !== parseInt(currentLevel, 10)) return false;
        
        // 等级范围筛选
        if (currentLevelRange !== "全部") {
            const [minLevel, maxLevel] = currentLevelRange.split('-').map(Number);
            if (lv < minLevel || lv > maxLevel) return false;
        }
        
        // 经验值范围筛选
        if (currentExpRange !== "全部") {
            const [minExp, maxExp] = currentExpRange.split('-').map(Number);
            if (exp < minExp || exp > maxExp) return false;
        }
        
        return true;
    });
    
    // 排序配方
    filteredRecipes.sort((a, b) => {
        switch (currentSort) {
            case "等级升序":
                return (a.lv || 0) - (b.lv || 0);
            case "等级降序":
                return (b.lv || 0) - (a.lv || 0);
            case "经验值升序":
                return (a.exp || 0) - (b.exp || 0);
            case "经验值降序":
                return (b.exp || 0) - (a.exp || 0);
            case "分类":
                return (a.category || '').localeCompare(b.category || '');
            default: // 名称
                return a.name.localeCompare(b.name);
        }
    });
    
    // 显示筛选结果统计
    const statsDiv = document.createElement('div');
    statsDiv.style.marginBottom = '12px';
    statsDiv.style.padding = '8px 12px';
    statsDiv.style.backgroundColor = '#f6f8fa';
    statsDiv.style.borderRadius = '6px';
    statsDiv.style.fontSize = '14px';
    statsDiv.style.color = '#656d76';
    statsDiv.innerHTML = `显示 ${filteredRecipes.length} 个配方（共 ${allRecipes.length} 个）`;
    recipeList.appendChild(statsDiv);
    
    for (const recipe of filteredRecipes) {
        const { name, category, materials, lv, exp } = recipe;
        
        let materialsHtml = '';
        if (typeof materials === 'object' && materials !== null) {
            materialsHtml = Object.entries(materials)
                .filter(([mat, qty]) => typeof qty === 'number' && !isNaN(qty))
                .map(([mat, qty]) => `${mat} × ${qty}`).join('，');
        }
        
        // 等级和经验值显示
        const levelInfo = lv ? `Lv.${lv}` : '';
        const expInfo = exp ? `Exp.${exp}` : '';
        const levelExpText = [levelInfo, expInfo].filter(Boolean).join(' | ');
        
        const div = document.createElement('div');
        div.className = 'recipe-item';
        div.innerHTML = `
            <span>
                <strong>${name}</strong> 
                <span class="recipe-category">[${category || '其他'}]</span>
                ${levelExpText ? `<span class="level-exp-info">(${levelExpText})</span>` : ''}
                <br><span class="recipe-materials">${materialsHtml}</span>
            </span>
            <span>
                <button class="btn-primary" onclick="editRecipe('${name}')">编辑</button>
                <button class="btn-secondary" onclick="deleteRecipe('${name}')">删除</button>
            </span>
        `;
        recipeList.appendChild(div);
    }
}

// 分类下拉记忆功能
const CATEGORY_KEY = 'last_selected_category';
const categorySelect = document.getElementById('newRecipeCategory');
if (categorySelect) {
    // 页面加载时，优先读取localStorage
    const lastCat = localStorage.getItem(CATEGORY_KEY);
    if (lastCat && Array.from(categorySelect.options).some(opt => opt.value === lastCat)) {
        categorySelect.value = lastCat;
    }
    // 选择分类时保存
    categorySelect.addEventListener('change', function() {
        localStorage.setItem(CATEGORY_KEY, this.value);
    });
}

function addRecipe() {
    const name = document.getElementById('newRecipeName').value.trim();
    const materialsStr = document.getElementById('newRecipeMaterials').value.trim();
    const category = document.getElementById('newRecipeCategory').value;
    const level = document.getElementById('newRecipeLevel').value;
    const exp = document.getElementById('newRecipeExp').value;
    if (!name || !materialsStr) return;
    const materials = {};
    materialsStr.split('，').forEach(pair => {
        const [mat, qty] = pair.split('：');
        if(mat && qty) materials[mat.trim()] = parseInt(qty.trim(), 10);
    });
    
    // 生成唯一ID
    const id = Date.now().toString();
    recipes[id] = { 
        name,
        category, 
        exp: parseInt(exp, 10),
        lv: parseInt(level, 10),
        materials, 
        isEvent: false 
    };
    nameToIdMap[name] = id;
    
    localStorage.setItem('recipes', JSON.stringify(recipes));
    displayRecipes();
    document.getElementById('newRecipeName').value = '';
    document.getElementById('newRecipeMaterials').value = '';
    document.getElementById('newRecipeLevel').value = '';
    document.getElementById('newRecipeExp').value = '';
    // 不重置分类，保持上次选择
    // 自动刷新材料名联想建议
    if (typeof materialInput !== 'undefined' && materialInput) {
        materialInput.dispatchEvent(new Event('input'));
    }
}

// 编辑配方
function editRecipe(name) {
    const recipe = getRecipeByName(name);
    if (!recipe) return;
    
    const { category, materials, lv, exp } = recipe;
    const newName = prompt('新配方名称:', name);
    if (!newName) return;
    const newMaterialsStr = prompt('新配方材料（格式：材料1：数量1，材料2：数量2）:', Object.entries(materials).map(([mat, qty]) => `${mat}：${qty}`).join('，'));
    if (!newMaterialsStr) return;
    let newCategory = prompt('新分类（可选: ' + CATEGORIES.join('/') + '）:', category);
    if (!CATEGORIES.includes(newCategory)) newCategory = category;
    const newLevel = prompt('新等级要求:', lv || 1);
    const newExp = prompt('新单次经验:', exp || 0);
    
    const newMaterials = {};
    newMaterialsStr.split('，').forEach(pair => {
        const [mat, qty] = pair.split('：');
        if(mat && qty) newMaterials[mat.trim()] = parseInt(qty.trim(), 10);
    });
    
    // 删除旧配方
    if (nameToIdMap[name]) {
        delete recipes[nameToIdMap[name]];
        delete nameToIdMap[name];
    } else {
        delete recipes[name];
    }
    
    // 添加新配方
    recipes[newName] = { 
        category: newCategory, 
        materials: newMaterials,
        lv: parseInt(newLevel, 10) || 1,
        exp: parseInt(newExp, 10) || 0
    };
    nameToIdMap[newName] = newName;
    
    localStorage.setItem('recipes', JSON.stringify(recipes));
    displayRecipes();
}

// 删除配方
function deleteRecipe(name) {
    if (confirm(`确定删除配方「${name}」吗？`)) {
        if (nameToIdMap[name]) {
            delete recipes[nameToIdMap[name]];
            delete nameToIdMap[name];
        } else {
            delete recipes[name];
        }
        localStorage.setItem('recipes', JSON.stringify(recipes));
        displayRecipes();
    }
}

// 下拉联想建议功能
const itemInput = document.getElementById('item');
const autocompleteList = document.getElementById('autocomplete-list');
let currentFocus = -1;

itemInput.addEventListener('input', function() {
    const value = this.value.trim();
    autocompleteList.innerHTML = '';
    if (!value) {
        autocompleteList.style.display = 'none';
        return;
    }
    
    // 获取所有配方名称
    const names = [];
    for (const [id, recipe] of Object.entries(recipes)) {
        if (recipe.name) {
            names.push(recipe.name);
        } else {
            // 兼容旧结构
            names.push(id);
        }
    }
    
    const filteredNames = names.filter(name => name.includes(value));
    if (filteredNames.length === 0) {
        autocompleteList.style.display = 'none';
        return;
    }
    
    filteredNames.forEach((name, idx) => {
        const div = document.createElement('div');
        div.className = 'autocomplete-item';
        div.innerHTML = name.replace(value, `<b>${value}</b>`);
        div.addEventListener('mousedown', function(e) {
            itemInput.value = name;
            autocompleteList.style.display = 'none';
        });
        autocompleteList.appendChild(div);
    });
    autocompleteList.style.display = 'block';
    currentFocus = -1;
});

itemInput.addEventListener('keydown', function(e) {
    const items = autocompleteList.querySelectorAll('.autocomplete-item');
    if (!items.length) return;
    if (e.key === 'ArrowDown') {
        currentFocus++;
        if (currentFocus >= items.length) currentFocus = 0;
        setActive(items);
        e.preventDefault();
    } else if (e.key === 'ArrowUp') {
        currentFocus--;
        if (currentFocus < 0) currentFocus = items.length - 1;
        setActive(items);
        e.preventDefault();
    } else if (e.key === 'Enter') {
        if (currentFocus > -1) {
            items[currentFocus].dispatchEvent(new Event('mousedown'));
            e.preventDefault();
        }
    }
});

function setActive(items) {
    items.forEach((item, idx) => {
        item.classList.toggle('active', idx === currentFocus);
    });
    if (currentFocus > -1 && items[currentFocus]) {
        items[currentFocus].scrollIntoView({block: 'nearest'});
    }
}

document.addEventListener('click', function(e) {
    if (!itemInput.contains(e.target) && !autocompleteList.contains(e.target)) {
        autocompleteList.style.display = 'none';
    }
});

window.onload = function() {
    // 材料名联想建议功能
    function getAllMaterialNames() {
        const set = new Set();
        for (const [id, recipe] of Object.entries(recipes)) {
            const mats = recipe.materials;
            if (typeof mats === 'object' && mats !== null) {
                Object.keys(mats).forEach(mat => set.add(String(mat).trim()));
            }
        }
        return Array.from(set);
    }
    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    const materialInput = document.getElementById('materialSuggestInput');
    const materialList = document.getElementById('material-autocomplete-list');
    const mainMaterialInput = document.getElementById('newRecipeMaterials');
    let matCurrentFocus = -1;
    if (materialInput && materialList && mainMaterialInput) {
        materialInput.addEventListener('input', function() {
            const value = this.value.trim();
            materialList.innerHTML = '';
            if (!value) {
                materialList.style.display = 'none';
                return;
            }
            const names = getAllMaterialNames();
            // 优先前缀匹配，再模糊匹配，全部去空格
            const prefixMatches = names.filter(name => name.trim().startsWith(value));
            const fuzzyMatches = names.filter(name => !name.trim().startsWith(value) && name.trim().includes(value));
            const allMatches = [...prefixMatches, ...fuzzyMatches];
            if (allMatches.length === 0) {
                materialList.style.display = 'none';
                return;
            }
            allMatches.forEach((name, idx) => {
                const safeValue = escapeRegExp(value);
                const reg = new RegExp(safeValue, 'g');
                const showName = name.replace(reg, `<b>${value}</b>`);
                const div = document.createElement('div');
                div.className = 'autocomplete-item';
                div.innerHTML = showName;
                div.addEventListener('mousedown', function(e) {
                    // 插入到主材料输入框末尾
                    let cur = mainMaterialInput.value.trim();
                    if (cur && !cur.endsWith('，')) cur += '，';
                    mainMaterialInput.value = cur + name + '：';
                    mainMaterialInput.focus();
                    // 光标移到末尾
                    mainMaterialInput.setSelectionRange(mainMaterialInput.value.length, mainMaterialInput.value.length);
                    materialInput.value = '';
                    materialList.style.display = 'none';
                });
                materialList.appendChild(div);
            });
            materialList.style.display = 'block';
            matCurrentFocus = -1;
        });
        materialInput.addEventListener('keydown', function(e) {
            const items = materialList.querySelectorAll('.autocomplete-item');
            if (!items.length) return;
            if (e.key === 'ArrowDown') {
                matCurrentFocus++;
                if (matCurrentFocus >= items.length) matCurrentFocus = 0;
                setMatActive(items);
                e.preventDefault();
            } else if (e.key === 'ArrowUp') {
                matCurrentFocus--;
                if (matCurrentFocus < 0) matCurrentFocus = items.length - 1;
                setMatActive(items);
                e.preventDefault();
            } else if (e.key === 'Enter') {
                if (matCurrentFocus > -1) {
                    items[matCurrentFocus].dispatchEvent(new Event('mousedown'));
                    e.preventDefault();
                }
            }
        });
        function setMatActive(items) {
            items.forEach((item, idx) => {
                item.classList.toggle('active', idx === matCurrentFocus);
            });
            if (matCurrentFocus > -1 && items[matCurrentFocus]) {
                items[matCurrentFocus].scrollIntoView({block: 'nearest'});
            }
        }
        document.addEventListener('click', function(e) {
            if (!materialInput.contains(e.target) && !materialList.contains(e.target)) {
                materialList.style.display = 'none';
            }
        });
    }
};

// 导出配方
function exportRecipes() {
    const data = JSON.stringify(recipes, null, 2);
    const blob = new Blob([data], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'recipes.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// 导入配方
function importRecipes(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const imported = JSON.parse(e.target.result);
            if (typeof imported === 'object' && imported !== null) {
                recipes = imported;
                // 导入后自动升级数据结构
                upgradeRecipesStructure();
                localStorage.setItem('recipes', JSON.stringify(recipes));
                displayRecipes();
                alert('配方导入成功！');
            } else {
                alert('导入的文件格式不正确！');
            }
        } catch {
            alert('导入的文件不是有效的JSON！');
        }
    };
    reader.readAsText(file);
    // 清空input，便于连续导入
    event.target.value = '';
}

// 导入/导出配方模态框控制
function openImportExportModal() {
    document.getElementById('importExportModal').style.display = 'block';
}
function closeImportExportModal() {
    document.getElementById('importExportModal').style.display = 'none';
}

function clearRecipes() {
    if (confirm('确定要清空本地配方库吗？此操作不可恢复！')) {
        localStorage.removeItem('recipes');
        location.reload();
    }
}

// 测试函数：重置为默认配方
function resetToDefault() {
    localStorage.removeItem('recipes');
    location.reload();
}

// 测试函数：简单计算
function testCalculate() {
    const testRecipes = {
        "面包": { category: "料理制作", materials: { "小麦": 3, "水": 1 } },
        "小麦": { category: "其他", materials: {} }  // 基础材料
    };
    
    const result = {};
    getBaseMaterials("面包", 1, result);
    console.log('测试计算结果:', result);
    alert('测试完成，请查看控制台');
}

// 调试函数：检查特定配方
function checkRecipe(name) {
    console.log('检查配方:', name);
    console.log('是否存在:', recipes.hasOwnProperty(name));
    console.log('配方内容:', recipes[name]);
    console.log('所有配方名称:', Object.keys(recipes));
}

// 调试函数：检查材料配方
function checkMaterialRecipes() {
    const materials = ['陶瓷碗', '构树木板', '檀木材料', '玻璃', '种子', '布料'];
    materials.forEach(mat => {
        const recipe = getRecipeByName(mat);
        console.log(`材料「${mat}」的配方:`, recipe);
    });
}

// 显示配方统计信息
function showRecipeStats() {
    const allRecipes = [];
    for (const [id, recipe] of Object.entries(recipes)) {
        if (recipe.name) {
            allRecipes.push({ id, ...recipe });
        } else {
            allRecipes.push({ id, name: id, ...recipe });
        }
    }
    
    const stats = {
        total: allRecipes.length,
        byCategory: {},
        byLevel: {},
        maxLevel: 0,
        maxExp: 0
    };
    
    allRecipes.forEach(recipe => {
        const { category, lv, exp } = recipe;
        
        // 分类统计
        const cat = category || '其他';
        stats.byCategory[cat] = (stats.byCategory[cat] || 0) + 1;
        
        // 等级统计
        if (lv) {
            stats.byLevel[lv] = (stats.byLevel[lv] || 0) + 1;
            stats.maxLevel = Math.max(stats.maxLevel, lv);
        }
        
        // 最大经验值
        if (exp) {
            stats.maxExp = Math.max(stats.maxExp, exp);
        }
    });
    
    let html = `<h4>配方统计</h4>`;
    html += `<p><strong>总配方数：</strong>${stats.total}</p>`;
    html += `<p><strong>最高等级：</strong>Lv.${stats.maxLevel}</p>`;
    html += `<p><strong>最高经验值：</strong>${stats.maxExp}</p>`;
    
    html += `<p><strong>按分类统计：</strong></p><ul>`;
    Object.entries(stats.byCategory).forEach(([cat, count]) => {
        html += `<li>${cat}: ${count}个</li>`;
    });
    html += `</ul>`;
    
    alert('配方统计信息已输出到控制台');
    console.log('配方统计:', stats);
}

// 快速跳转到特定等级
function jumpToLevel(level) {
    currentLevel = level.toString();
    currentLevelRange = "全部";
    currentExpRange = "全部";
    currentSort = "等级升序";
    displayRecipes();
}

// 快速跳转到特定经验值范围
function jumpToExpRange(minExp, maxExp) {
    currentExpRange = `${minExp}-${maxExp}`;
    currentLevel = "全部";
    currentLevelRange = "全部";
    currentSort = "经验值升序";
    displayRecipes();
}

// 重置所有筛选条件
function resetFilters() {
    currentCategory = "全部";
    currentLevel = "全部";
    currentLevelRange = "全部";
    currentExpRange = "全部";
    currentSort = "名称";
    displayRecipes();
}
</script>
</body>
</html> 
